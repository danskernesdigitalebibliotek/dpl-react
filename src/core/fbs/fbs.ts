/**
 * Generated by orval v7.2.0 üç∫
 * Do not edit manually.
 * FBS Adapter
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from "react-query";
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from "react-query";
import type {
  AgencyBranch,
  AuthenticatedPatronV4,
  AuthenticatedPatronV6,
  AvailabilityV3,
  CreatePatronRequestV3,
  CreateReservationBatch,
  CreateReservationBatchV2,
  DeleteReservationsParams,
  FeeV2,
  GetAvailabilityV3Params,
  GetBranchesParams,
  GetFeesV2Params,
  GetHoldingsLogisticsV1Params,
  HoldingsForBibliographicalRecordLogisticsV1,
  LoanV2,
  PatronWithGuardianRequest,
  RenewedLoanV2,
  ReservationDetails,
  ReservationDetailsV2,
  ReservationResponseV2,
  UpdateGuardianRequest,
  UpdatePatronRequestV4,
  UpdateReservationBatch
} from "./model";
import { fetcher } from "./mutator/fetcher";
import type { ErrorType, BodyType } from "./mutator/fetcher";

/**
 *
 Returns array of branches.
 <p>Can be used for giving the patron the option of choosing a preferred branch or where to pick up
 reservations.</p>
 * @summary Get branches for an agency.
 */
export const getBranches = (
  params?: GetBranchesParams,
  signal?: AbortSignal
) => {
  return fetcher<AgencyBranch[]>({
    url: `/external/v1/agencyid/branches`,
    method: "GET",
    params,
    signal
  });
};

export const getGetBranchesQueryKey = (params?: GetBranchesParams) => {
  return [
    `/external/v1/agencyid/branches`,
    ...(params ? [params] : [])
  ] as const;
};

export const getGetBranchesQueryOptions = <
  TData = Awaited<ReturnType<typeof getBranches>>,
  TError = ErrorType<void>
>(
  params?: GetBranchesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getBranches>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBranchesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranches>>> = ({
    signal
  }) => getBranches(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getBranches>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetBranchesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBranches>>
>;
export type GetBranchesQueryError = ErrorType<void>;

/**
 * @summary Get branches for an agency.
 */

export function useGetBranches<
  TData = Awaited<ReturnType<typeof getBranches>>,
  TError = ErrorType<void>
>(
  params?: GetBranchesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getBranches>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetBranchesQueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Delete existing reservations.
 */
export const deleteReservations = (params: DeleteReservationsParams) => {
  return fetcher<void>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "DELETE",
    params
  });
};

export const getDeleteReservationsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteReservations>>,
    TError,
    { params: DeleteReservationsParams },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteReservations>>,
  TError,
  { params: DeleteReservationsParams },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteReservations>>,
    { params: DeleteReservationsParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteReservations(params);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteReservationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteReservations>>
>;

export type DeleteReservationsMutationError = ErrorType<void>;

/**
 * @summary Delete existing reservations.
 */
export const useDeleteReservations = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteReservations>>,
    TError,
    { params: DeleteReservationsParams },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteReservations>>,
  TError,
  { params: DeleteReservationsParams },
  TContext
> => {
  const mutationOptions = getDeleteReservationsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of reservation details.
 <p>When the patron picks up the reserved materials,
 the reservation will no longer be returned.
 Expired or deleted reservations will not be returned.</p>

 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'loan'
 .</p>
 * @summary Get all unfulfilled reservations made by the patron (DEPRECATED).
 */
export const getReservations = (signal?: AbortSignal) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "GET",
    signal
  });
};

export const getGetReservationsQueryKey = () => {
  return [`/external/v1/agencyid/patrons/patronid/reservations`] as const;
};

export const getGetReservationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getReservations>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservations>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReservationsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReservations>>> = ({
    signal
  }) => getReservations(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReservations>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetReservationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReservations>>
>;
export type GetReservationsQueryError = ErrorType<void>;

/**
 * @summary Get all unfulfilled reservations made by the patron (DEPRECATED).
 */

export function useGetReservations<
  TData = Awaited<ReturnType<typeof getReservations>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservations>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetReservationsQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 Returns an array of reservation details for the created reservations.
 <p></p>
 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 <p>
     When making a reservation of a periodical, the values to put in the PeriodicalReservation structure can be obtained
     from the periodical information retrieved with the Catalog service.
 </p>
 <p><b>This method has been deprecated use /external/v1/{agencyid}/patrons/{patronid}/reservations/v2 instead</b></p>
 * @summary Create new reservations for the patron (DEPRECATED).
 */
export const addReservationsDeprecated = (
  createReservationBatch: BodyType<CreateReservationBatch>
) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createReservationBatch
  });
};

export const getAddReservationsDeprecatedMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    TError,
    { data: BodyType<CreateReservationBatch> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addReservationsDeprecated>>,
  TError,
  { data: BodyType<CreateReservationBatch> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    { data: BodyType<CreateReservationBatch> }
  > = (props) => {
    const { data } = props ?? {};

    return addReservationsDeprecated(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddReservationsDeprecatedMutationResult = NonNullable<
  Awaited<ReturnType<typeof addReservationsDeprecated>>
>;
export type AddReservationsDeprecatedMutationBody =
  BodyType<CreateReservationBatch>;
export type AddReservationsDeprecatedMutationError = ErrorType<void>;

/**
 * @summary Create new reservations for the patron (DEPRECATED).
 */
export const useAddReservationsDeprecated = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    TError,
    { data: BodyType<CreateReservationBatch> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addReservationsDeprecated>>,
  TError,
  { data: BodyType<CreateReservationBatch> },
  TContext
> => {
  const mutationOptions = getAddReservationsDeprecatedMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of the updated reservation details.
 <p></p>
 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 * @summary Update existing reservations.
 */
export const updateReservations = (
  updateReservationBatch: BodyType<UpdateReservationBatch>
) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateReservationBatch
  });
};

export const getUpdateReservationsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReservations>>,
    TError,
    { data: BodyType<UpdateReservationBatch> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateReservations>>,
  TError,
  { data: BodyType<UpdateReservationBatch> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReservations>>,
    { data: BodyType<UpdateReservationBatch> }
  > = (props) => {
    const { data } = props ?? {};

    return updateReservations(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateReservationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateReservations>>
>;
export type UpdateReservationsMutationBody = BodyType<UpdateReservationBatch>;
export type UpdateReservationsMutationError = ErrorType<void>;

/**
 * @summary Update existing reservations.
 */
export const useUpdateReservations = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReservations>>,
    TError,
    { data: BodyType<UpdateReservationBatch> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateReservations>>,
  TError,
  { data: BodyType<UpdateReservationBatch> },
  TContext
> => {
  const mutationOptions = getUpdateReservationsMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of reservation details.
 <p>When the patron picks up the reserved materials,
 the reservation will no longer be returned.
 Expired or deleted reservations will not be returned.</p>

 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 The response contains reservationType, which can be any of these values:
 <ul>
     <li>- NORMAL</li>
     <li>- PARALLEL</li>
     <li>- SERIAL</li>
     <li>- INTER_LIBRARY</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, iit should be treated as 'normal'</p>
 <p>The response contains a transactionId, which links together parallel reservations.</p>
 * @summary Get all unfulfilled reservations made by the patron.
 */
export const getReservationsV2 = (signal?: AbortSignal) => {
  return fetcher<ReservationDetailsV2[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations/v2`,
    method: "GET",
    signal
  });
};

export const getGetReservationsV2QueryKey = () => {
  return [`/external/v1/agencyid/patrons/patronid/reservations/v2`] as const;
};

export const getGetReservationsV2QueryOptions = <
  TData = Awaited<ReturnType<typeof getReservationsV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservationsV2>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReservationsV2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getReservationsV2>>
  > = ({ signal }) => getReservationsV2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getReservationsV2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetReservationsV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getReservationsV2>>
>;
export type GetReservationsV2QueryError = ErrorType<void>;

/**
 * @summary Get all unfulfilled reservations made by the patron.
 */

export function useGetReservationsV2<
  TData = Awaited<ReturnType<typeof getReservationsV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservationsV2>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetReservationsV2QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 <p>Given a CreateReservationBatch, it creates a list of reservations and returns a ReservationResponse.</p>
 <p>The CreateReservationBatch.type indicates the reservation type of the request. If left out the request will be considered of type
 normal. The type can be any of the following values:</p>
 <ul>
     <li>- normal</li>
     <li>- parallel</li>
 </ul>
 <p>The values are subject to change.</p>

 <p>ReservationResponse.success indicates if the reservations were created sucessfully. If any of the reservations have failed then all
 reservations will be failed and ReservationResponse.success will be false. If all reservations are successfully created ReservationResponse.success will be true.

 <p></p>

 <p>ReservationResponse.reservationResults contains details about each reservation.
 A ReservationResult.result has the status of a reservation and can be any of the following values:</p>
 <ul>
     <li>- success</li>
     <li>- patron_is_blocked</li>
     <li>- patron_not_found</li>
     <li>- already_reserved</li>
     <li>- already_loaned</li>
     <li>- material_not_loanable</li>
     <li>- material_not_reservable</li>
     <li>- material_lost</li>
     <li>- material_Discarded</li>
     <li>- loaning_profile_not_found</li>
     <li>- material_not_found</li>
     <li>- material_part_of_collection</li>
     <li>- not_reservable</li>
     <li>- no_reservable_materials</li>
     <li>- interlibrary_material_not_reservable</li>
     <li>- previously_loaned_by_homebound_patron</li>
     <li>- exceeds_max_reservations</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as an error.</p>

 <p></p>

 The reservation detail in the response contains a reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>

 <p></p>

 <p>
     When making a reservation of a periodical, the values to put in the PeriodicalReservation structure can be obtained
     from the periodical information retrieved with the Catalog service.
 </p>
 * @summary Create new reservations for the patron.
 */
export const addReservationsV2 = (
  createReservationBatchV2: BodyType<CreateReservationBatchV2>
) => {
  return fetcher<ReservationResponseV2>({
    url: `/external/v1/agencyid/patrons/patronid/reservations/v2`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createReservationBatchV2
  });
};

export const getAddReservationsV2MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsV2>>,
    TError,
    { data: BodyType<CreateReservationBatchV2> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof addReservationsV2>>,
  TError,
  { data: BodyType<CreateReservationBatchV2> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReservationsV2>>,
    { data: BodyType<CreateReservationBatchV2> }
  > = (props) => {
    const { data } = props ?? {};

    return addReservationsV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddReservationsV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof addReservationsV2>>
>;
export type AddReservationsV2MutationBody = BodyType<CreateReservationBatchV2>;
export type AddReservationsV2MutationError = ErrorType<void>;

/**
 * @summary Create new reservations for the patron.
 */
export const useAddReservationsV2 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsV2>>,
    TError,
    { data: BodyType<CreateReservationBatchV2> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof addReservationsV2>>,
  TError,
  { data: BodyType<CreateReservationBatchV2> },
  TContext
> => {
  const mutationOptions = getAddReservationsV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of availability for each bibliographical record.
 * @summary Get availability of bibliographical records.
 */
export const getAvailabilityV3 = (
  params: GetAvailabilityV3Params,
  signal?: AbortSignal
) => {
  return fetcher<AvailabilityV3[]>({
    url: `/external/agencyid/catalog/availability/v3`,
    method: "GET",
    params,
    signal
  });
};

export const getGetAvailabilityV3QueryKey = (
  params: GetAvailabilityV3Params
) => {
  return [
    `/external/agencyid/catalog/availability/v3`,
    ...(params ? [params] : [])
  ] as const;
};

export const getGetAvailabilityV3QueryOptions = <
  TData = Awaited<ReturnType<typeof getAvailabilityV3>>,
  TError = ErrorType<void>
>(
  params: GetAvailabilityV3Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAvailabilityV3>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAvailabilityV3QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAvailabilityV3>>
  > = ({ signal }) => getAvailabilityV3(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAvailabilityV3>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetAvailabilityV3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAvailabilityV3>>
>;
export type GetAvailabilityV3QueryError = ErrorType<void>;

/**
 * @summary Get availability of bibliographical records.
 */

export function useGetAvailabilityV3<
  TData = Awaited<ReturnType<typeof getAvailabilityV3>>,
  TError = ErrorType<void>
>(
  params: GetAvailabilityV3Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAvailabilityV3>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetAvailabilityV3QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 Returns an array of holdings for each bibliographical record.
 The holdings lists the materials on each placement, and whether they are available on-shelf or lent out.
 * @summary Get placement holdings for bibliographical records.
 */
export const getHoldingsLogisticsV1 = (
  params: GetHoldingsLogisticsV1Params,
  signal?: AbortSignal
) => {
  return fetcher<HoldingsForBibliographicalRecordLogisticsV1[]>({
    url: `/external/agencyid/catalog/holdingsLogistics/v1`,
    method: "GET",
    params,
    signal
  });
};

export const getGetHoldingsLogisticsV1QueryKey = (
  params: GetHoldingsLogisticsV1Params
) => {
  return [
    `/external/agencyid/catalog/holdingsLogistics/v1`,
    ...(params ? [params] : [])
  ] as const;
};

export const getGetHoldingsLogisticsV1QueryOptions = <
  TData = Awaited<ReturnType<typeof getHoldingsLogisticsV1>>,
  TError = ErrorType<void>
>(
  params: GetHoldingsLogisticsV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getHoldingsLogisticsV1>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetHoldingsLogisticsV1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getHoldingsLogisticsV1>>
  > = ({ signal }) => getHoldingsLogisticsV1(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHoldingsLogisticsV1>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetHoldingsLogisticsV1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getHoldingsLogisticsV1>>
>;
export type GetHoldingsLogisticsV1QueryError = ErrorType<void>;

/**
 * @summary Get placement holdings for bibliographical records.
 */
export const useGetHoldingsLogisticsV1 = <
  TData = Awaited<ReturnType<typeof getHoldingsLogisticsV1>>,
  TError = ErrorType<void>
>(
  params: GetHoldingsLogisticsV1Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getHoldingsLogisticsV1>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const queryOptions = getGetHoldingsLogisticsV1QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 Returns array of fees.
 <p>If the fee covers loaned materials, information about the materials is returned.
 Each fee in the response includes a 'type', which is used to distinguish between different types of
 fees.</p>
 <p>If the material exists no more, which is the case for fees that are related to closed interlibraryloans,
 then the fee is still returned, but without material information</p>
 The list of available types currently is
 <ul>
 <li>fee</li>
 <li>compensation</li>
 </ul>
 <p>While the type can be used by client systems to look up a suitable display message for the end user, it is
 important that unrecognized types are treated as 'other'.</p>
 * @summary List of fees in FBS for the patron with all available information about the fee.
 */
export const getFeesV2 = (params: GetFeesV2Params, signal?: AbortSignal) => {
  return fetcher<FeeV2[]>({
    url: `/external/agencyid/patron/patronid/fees/v2`,
    method: "GET",
    params,
    signal
  });
};

export const getGetFeesV2QueryKey = (params: GetFeesV2Params) => {
  return [
    `/external/agencyid/patron/patronid/fees/v2`,
    ...(params ? [params] : [])
  ] as const;
};

export const getGetFeesV2QueryOptions = <
  TData = Awaited<ReturnType<typeof getFeesV2>>,
  TError = ErrorType<void>
>(
  params: GetFeesV2Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getFeesV2>>,
      TError,
      TData
    >;
  }
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFeesV2QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeesV2>>> = ({
    signal
  }) => getFeesV2(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFeesV2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetFeesV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getFeesV2>>
>;
export type GetFeesV2QueryError = ErrorType<void>;

/**
 * @summary List of fees in FBS for the patron with all available information about the fee.
 */

export function useGetFeesV2<
  TData = Awaited<ReturnType<typeof getFeesV2>>,
  TError = ErrorType<void>
>(
  params: GetFeesV2Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getFeesV2>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetFeesV2QueryOptions(params, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 When a patron doesn't have a patron account in the library system, but logs in using a trusted authentication
 source (e.g NemId), the patron account can be created using this service. Name and address will be automatically
 fetched from CPR-Registry, and cannot be supplied by the client. If the CPR-Registry is not authorized to
 provide information about the patron, then repsonse message 404 will be sent back
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Create a new patron who is a person.
 */
export const createV4 = (
  createPatronRequestV3: BodyType<CreatePatronRequestV3>
) => {
  return fetcher<AuthenticatedPatronV4>({
    url: `/external/agencyid/patrons/v4`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: createPatronRequestV3
  });
};

export const getCreateV4MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createV4>>,
    TError,
    { data: BodyType<CreatePatronRequestV3> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createV4>>,
  TError,
  { data: BodyType<CreatePatronRequestV3> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createV4>>,
    { data: BodyType<CreatePatronRequestV3> }
  > = (props) => {
    const { data } = props ?? {};

    return createV4(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateV4MutationResult = NonNullable<
  Awaited<ReturnType<typeof createV4>>
>;
export type CreateV4MutationBody = BodyType<CreatePatronRequestV3>;
export type CreateV4MutationError = ErrorType<void>;

/**
 * @summary Create a new patron who is a person.
 */
export const useCreateV4 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createV4>>,
    TError,
    { data: BodyType<CreatePatronRequestV3> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createV4>>,
  TError,
  { data: BodyType<CreatePatronRequestV3> },
  TContext
> => {
  const mutationOptions = getCreateV4MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *

 Returns the id of the patron if the request succeeds.
 Name and address will be automatically fetched from the CPR-Registry.
 <p>If the CPR-Registry is not authorized to provide information about the patron, then response message 404 will be sent back.</p>
 <p>If the supplied cpr number of the patron equals that of the guardian, then response message 400 will be sent back.</p>
 <p>If the email of the guardian is invalid, then response message 400 will be sent back.</p>
 <p>If an email or phone number for the patron is supplied and it is invalid, then response message 400 will be sent back.</p>
 <p>In case of a successful creation of the patron, a confirmation email is sent to the guardian.
 In case of failure an email is sent to guardian stating the creation failed.</p>
 * @summary Creates a person patron with a guardian (eg A financial responsible).
 */
export const createWithGuardian = (
  patronWithGuardianRequest: BodyType<PatronWithGuardianRequest>
) => {
  return fetcher<number>({
    url: `/external/agencyid/patrons/withGuardian/v1`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: patronWithGuardianRequest
  });
};

export const getCreateWithGuardianMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createWithGuardian>>,
    TError,
    { data: BodyType<PatronWithGuardianRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createWithGuardian>>,
  TError,
  { data: BodyType<PatronWithGuardianRequest> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createWithGuardian>>,
    { data: BodyType<PatronWithGuardianRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createWithGuardian(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateWithGuardianMutationResult = NonNullable<
  Awaited<ReturnType<typeof createWithGuardian>>
>;
export type CreateWithGuardianMutationBody =
  BodyType<PatronWithGuardianRequest>;
export type CreateWithGuardianMutationError = ErrorType<void>;

/**
 * @summary Creates a person patron with a guardian (eg A financial responsible).
 */
export const useCreateWithGuardian = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createWithGuardian>>,
    TError,
    { data: BodyType<PatronWithGuardianRequest> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof createWithGuardian>>,
  TError,
  { data: BodyType<PatronWithGuardianRequest> },
  TContext
> => {
  const mutationOptions = getCreateWithGuardianMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 If the person doesn't have a guardian, a new one is created with the information provided.

 Returns the id of the patron if the request succeeds.
 Name and address will be automatically fetched from the CPR-Registry.
 <p>If the CPR-Registry is not authorized to provide information about the patron and guardian, then response message 404 will be sent back.</p>
 <p>If the supplied cpr number of the patron equals that of the guardian, then response message 400 will be sent back.</p>
 <p>If the email of the guardian is invalid, then response message 400 will be sent back.</p>
 <p>In case of a successful update of the guardian, a confirmation email is sent to the guardian.
 In case of failure an email is sent to guardian stating the update failed.</p>
 * @summary Updates a person patron's guardian (eg A financial responsible).
 */
export const updateGuardian = (
  updateGuardianRequest: BodyType<UpdateGuardianRequest>
) => {
  return fetcher<number>({
    url: `/external/agencyid/patrons/withGuardian/v1`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updateGuardianRequest
  });
};

export const getUpdateGuardianMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGuardian>>,
    TError,
    { data: BodyType<UpdateGuardianRequest> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGuardian>>,
  TError,
  { data: BodyType<UpdateGuardianRequest> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGuardian>>,
    { data: BodyType<UpdateGuardianRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return updateGuardian(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateGuardianMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGuardian>>
>;
export type UpdateGuardianMutationBody = BodyType<UpdateGuardianRequest>;
export type UpdateGuardianMutationError = ErrorType<void>;

/**
 * @summary Updates a person patron's guardian (eg A financial responsible).
 */
export const useUpdateGuardian = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGuardian>>,
    TError,
    { data: BodyType<UpdateGuardianRequest> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateGuardian>>,
  TError,
  { data: BodyType<UpdateGuardianRequest> },
  TContext
> => {
  const mutationOptions = getUpdateGuardianMutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of the updated loans.
 <p>
 If the materials could not be renewed, the return date will be unchanged.
 </p>
 <p>
 The response field renewalStatus will contain a list of one or more of these values:
 <ul>
 <li>- renewed</li>
 <li>- deniedReserved</li>
 <li>- deniedMaxRenewalsReached</li>
 <li>- deniedLoanerIsBlocked</li>
 <li>- deniedMaterialIsNotLoanable</li>
 <li>- deniedMaterialIsNotFound</li>
 <li>- deniedLoanerNotFound</li>
 <li>- deniedLoaningProfileNotFound</li>
 <li>- deniedOtherReason</li>
 </ul>
 <p>
 If any other value is encountered then it must be treated as 'deniedOtherReason'.
 </p>
 The response contains the field loanDetails.loanType, which can be any of these values:
 <ul>
 <li>- loan</li>
 <li>- interLibraryLoan</li>
 </ul>
 <p>
 The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other' .
 </p>
 * @summary Renew loans.
 */
export const renewLoansV2 = (renewLoansV2Body: BodyType<number[]>) => {
  return fetcher<RenewedLoanV2[]>({
    url: `/external/agencyid/patrons/patronid/loans/renew/v2`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: renewLoansV2Body
  });
};

export const getRenewLoansV2MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof renewLoansV2>>,
    TError,
    { data: BodyType<number[]> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof renewLoansV2>>,
  TError,
  { data: BodyType<number[]> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof renewLoansV2>>,
    { data: BodyType<number[]> }
  > = (props) => {
    const { data } = props ?? {};

    return renewLoansV2(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type RenewLoansV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof renewLoansV2>>
>;
export type RenewLoansV2MutationBody = BodyType<number[]>;
export type RenewLoansV2MutationError = ErrorType<void>;

/**
 * @summary Renew loans.
 */
export const useRenewLoansV2 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof renewLoansV2>>,
    TError,
    { data: BodyType<number[]> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof renewLoansV2>>,
  TError,
  { data: BodyType<number[]> },
  TContext
> => {
  const mutationOptions = getRenewLoansV2MutationOptions(options);

  return useMutation(mutationOptions);
};

/**
 *
 Returns an array of loans.
 <p>
 </p>
 If a loan is not renewable then the field renewalStatus will contain a list of one or more of these values:
 <ul>
 <li>- deniedReserved</li>
 <li>- deniedMaxRenewalsReached</li>
 <li>- deniedLoanerIsBlocked</li>
 <li>- deniedMaterialIsNotLoanable</li>
 <li>- deniedMaterialIsNotFound</li>
 <li>- deniedLoanerNotFound</li>
 <li>- deniedLoaningProfileNotFound</li>
 <li>- deniedOtherReason</li>
 </ul>
 <p>
 If any other value is encountered then it must be treated as 'deniedOtherReason'.
 </p>
 The response contains the field loanDetails.loanType, which can be any of these values:
 <ul>
 <li>- loan</li>
 <li>- interLibraryLoan</li>
 </ul>
 <p>
 The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other' .
 </p>
 <p>
 NOTE: Cicero can decide to skip evaluation of the returned loans to minimize response time for loaners with
 many loans. In that case isRenewable will have the value true, as if it were a successful validation.
 </p>
 * @summary Get list of current loans by the patron.
 */
export const getLoansV2 = (signal?: AbortSignal) => {
  return fetcher<LoanV2[]>({
    url: `/external/agencyid/patrons/patronid/loans/v2`,
    method: "GET",
    signal
  });
};

export const getGetLoansV2QueryKey = () => {
  return [`/external/agencyid/patrons/patronid/loans/v2`] as const;
};

export const getGetLoansV2QueryOptions = <
  TData = Awaited<ReturnType<typeof getLoansV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getLoansV2>>,
    TError,
    TData
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLoansV2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoansV2>>> = ({
    signal
  }) => getLoansV2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getLoansV2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetLoansV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoansV2>>
>;
export type GetLoansV2QueryError = ErrorType<void>;

/**
 * @summary Get list of current loans by the patron.
 */

export function useGetLoansV2<
  TData = Awaited<ReturnType<typeof getLoansV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getLoansV2>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLoansV2QueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 *
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Returns the patron details
 */
export const getPatronInformationByPatronIdV2 = (signal?: AbortSignal) => {
  return fetcher<AuthenticatedPatronV6>({
    url: `/external/agencyid/patrons/patronid/v2`,
    method: "GET",
    signal
  });
};

export const getGetPatronInformationByPatronIdV2QueryKey = () => {
  return [`/external/agencyid/patrons/patronid/v2`] as const;
};

export const getGetPatronInformationByPatronIdV2QueryOptions = <
  TData = Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
  TError = ErrorType<void>
>(
  queryOptions?: UseQueryOptions<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
    TError,
    TData
  >
) => {
  const queryKey =
    queryOptions?.queryKey ?? getGetPatronInformationByPatronIdV2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>
  > = ({ signal }) => getPatronInformationByPatronIdV2(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type GetPatronInformationByPatronIdV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>
>;
export type GetPatronInformationByPatronIdV2QueryError = ErrorType<void>;

/**
 * @summary Returns the patron details
 */

export function useGetPatronInformationByPatronIdV2<
  TData = Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
  TError = ErrorType<void>
>(
  queryOptions?: UseQueryOptions<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
    TError,
    TData
  >
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const options = getGetPatronInformationByPatronIdV2QueryOptions(queryOptions);

  const query = useQuery(options) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = options.queryKey;

  return query;
}

/**
 *
 The name and address cannot be supplied by the client. If the CPR-Registry is not authorized to provide
 information about the patron, then the name and address will not be updated.
 <p>It is possible to either update just the pincode, update just some patron settings, or update both.</p>
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Update information about the patron.
 */
export const updateV5 = (
  updatePatronRequestV4: BodyType<UpdatePatronRequestV4>
) => {
  return fetcher<AuthenticatedPatronV6>({
    url: `/external/agencyid/patrons/patronid/v5`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: updatePatronRequestV4
  });
};

export const getUpdateV5MutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateV5>>,
    TError,
    { data: BodyType<UpdatePatronRequestV4> },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateV5>>,
  TError,
  { data: BodyType<UpdatePatronRequestV4> },
  TContext
> => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateV5>>,
    { data: BodyType<UpdatePatronRequestV4> }
  > = (props) => {
    const { data } = props ?? {};

    return updateV5(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateV5MutationResult = NonNullable<
  Awaited<ReturnType<typeof updateV5>>
>;
export type UpdateV5MutationBody = BodyType<UpdatePatronRequestV4>;
export type UpdateV5MutationError = ErrorType<void>;

/**
 * @summary Update information about the patron.
 */
export const useUpdateV5 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateV5>>,
    TError,
    { data: BodyType<UpdatePatronRequestV4> },
    TContext
  >;
}): UseMutationResult<
  Awaited<ReturnType<typeof updateV5>>,
  TError,
  { data: BodyType<UpdatePatronRequestV4> },
  TContext
> => {
  const mutationOptions = getUpdateV5MutationOptions(options);

  return useMutation(mutationOptions);
};
