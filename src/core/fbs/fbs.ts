/**
 * Generated by orval v6.8.1 üç∫
 * Do not edit manually.
 * FBS Adapter
 * OpenAPI spec version: 1.0
 */
import {
  useQuery,
  useMutation,
  UseQueryOptions,
  UseMutationOptions,
  QueryFunction,
  MutationFunction,
  UseQueryResult,
  QueryKey
} from "react-query";
import type {
  AgencyBranch,
  GetBranchesParams,
  DeleteReservationsParams,
  ReservationDetails,
  CreateReservationBatch,
  UpdateReservationBatch,
  ReservationDetailsV2,
  ReservationResponseV2,
  CreateReservationBatchV2,
  AvailabilityV3,
  GetAvailabilityV3Params,
  HoldingsForBibliographicalRecordV3,
  GetHoldingsV3Params,
  FeeV2,
  GetFeesV2Params,
  AuthenticatedPatronV4,
  CreatePatronRequestV3,
  PatronWithGuardianRequest,
  UpdateGuardianRequest,
  RenewedLoanV2,
  LoanV2,
  AuthenticatedPatronV6,
  UpdatePatronRequestV4
} from "./model";
import { fetcher, ErrorType, BodyType } from "./mutator/fetcher";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * 
 Returns array of branches.
 <p>Can be used for giving the patron the option of choosing a preferred branch or where to pick up
 reservations.</p>
 * @summary Get branches for an agency.
 */
export const getBranches = (
  params?: GetBranchesParams,
  signal?: AbortSignal
) => {
  return fetcher<AgencyBranch[]>({
    url: `/external/v1/agencyid/branches`,
    method: "get",
    signal,
    params
  });
};

export const getGetBranchesQueryKey = (params?: GetBranchesParams) => [
  `/external/v1/agencyid/branches`,
  ...(params ? [params] : [])
];

export type GetBranchesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getBranches>>
>;
export type GetBranchesQueryError = ErrorType<void>;

export const useGetBranches = <
  TData = Awaited<ReturnType<typeof getBranches>>,
  TError = ErrorType<void>
>(
  params?: GetBranchesParams,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getBranches>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetBranchesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getBranches>>> = ({
    signal
  }) => getBranches(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getBranches>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * @summary Delete existing reservations.
 */
export const deleteReservations = (params?: DeleteReservationsParams) => {
  return fetcher<void>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "delete",
    params
  });
};

export type DeleteReservationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteReservations>>
>;

export type DeleteReservationsMutationError = ErrorType<unknown>;

export const useDeleteReservations = <
  TError = ErrorType<unknown>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteReservations>>,
    TError,
    { params?: DeleteReservationsParams },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteReservations>>,
    { params?: DeleteReservationsParams }
  > = (props) => {
    const { params } = props ?? {};

    return deleteReservations(params);
  };

  return useMutation<
    Awaited<ReturnType<typeof deleteReservations>>,
    TError,
    { params?: DeleteReservationsParams },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of reservation details.
 <p>When the patron picks up the reserved materials,
 the reservation will no longer be returned.
 Expired or deleted reservations will not be returned.</p>

 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'loan'
 .</p>
 * @summary Get all unfulfilled reservations made by the patron (DEPRECATED).
 */
export const getReservations = (signal?: AbortSignal) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "get",
    signal
  });
};

export const getGetReservationsQueryKey = () => [
  `/external/v1/agencyid/patrons/patronid/reservations`
];

export type GetReservationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getReservations>>
>;
export type GetReservationsQueryError = ErrorType<void>;

export const useGetReservations = <
  TData = Awaited<ReturnType<typeof getReservations>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservations>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReservationsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getReservations>>> = ({
    signal
  }) => getReservations(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getReservations>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 Returns an array of reservation details for the created reservations.
 <p></p>
 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 <p>
     When making a reservation of a periodical, the values to put in the PeriodicalReservation structure can be obtained
     from the periodical information retrieved with the Catalog service.
 </p>
 <p><b>This method has been deprecated use /external/v1/{agencyid}/patrons/{patronid}/reservations/add instead</b></p>
 * @summary Create new reservations for the patron (DEPRECATED).
 */
export const addReservationsDeprecated = (
  createReservationBatch: BodyType<CreateReservationBatch>
) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createReservationBatch
  });
};

export type AddReservationsDeprecatedMutationResult = NonNullable<
  Awaited<ReturnType<typeof addReservationsDeprecated>>
>;
export type AddReservationsDeprecatedMutationBody =
  BodyType<CreateReservationBatch>;
export type AddReservationsDeprecatedMutationError = ErrorType<void>;

export const useAddReservationsDeprecated = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    TError,
    { data: BodyType<CreateReservationBatch> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    { data: BodyType<CreateReservationBatch> }
  > = (props) => {
    const { data } = props ?? {};

    return addReservationsDeprecated(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof addReservationsDeprecated>>,
    TError,
    { data: BodyType<CreateReservationBatch> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of the updated reservation details.
 <p></p>
 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>
 The response contains loanType, which can be any of these values:
 <ul>
     <li>- loan</li>
     <li>- interLibraryLoan</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 * @summary Update existing reservations.
 */
export const updateReservations = (
  updateReservationBatch: BodyType<UpdateReservationBatch>
) => {
  return fetcher<ReservationDetails[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateReservationBatch
  });
};

export type UpdateReservationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateReservations>>
>;
export type UpdateReservationsMutationBody = BodyType<UpdateReservationBatch>;
export type UpdateReservationsMutationError = ErrorType<void>;

export const useUpdateReservations = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateReservations>>,
    TError,
    { data: BodyType<UpdateReservationBatch> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateReservations>>,
    { data: BodyType<UpdateReservationBatch> }
  > = (props) => {
    const { data } = props ?? {};

    return updateReservations(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateReservations>>,
    TError,
    { data: BodyType<UpdateReservationBatch> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of reservation details.
 <p>When the patron picks up the reserved materials,
 the reservation will no longer be returned.
 Expired or deleted reservations will not be returned.</p>

 The response contains reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'
 .</p>
 The response contains reservationType, which can be any of these values:
 <ul>
     <li>- NORMAL</li>
     <li>- PARALLEL</li>
     <li>- SERIAL</li>
     <li>- INTER_LIBRARY</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, iit should be treated as 'normal'</p>
 <p>The response contains a transactionId, which links together parallel reservations.</p>
 * @summary Get all unfulfilled reservations made by the patron.
 */
export const getReservationsV2 = (signal?: AbortSignal) => {
  return fetcher<ReservationDetailsV2[]>({
    url: `/external/v1/agencyid/patrons/patronid/reservations/v2`,
    method: "get",
    signal
  });
};

export const getGetReservationsV2QueryKey = () => [
  `/external/v1/agencyid/patrons/patronid/reservations/v2`
];

export type GetReservationsV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getReservationsV2>>
>;
export type GetReservationsV2QueryError = ErrorType<void>;

export const useGetReservationsV2 = <
  TData = Awaited<ReturnType<typeof getReservationsV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getReservationsV2>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetReservationsV2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getReservationsV2>>
  > = ({ signal }) => getReservationsV2(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getReservationsV2>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 <p>Given a CreateReservationBatch, it creates a list of reservations and returns a ReservationResponse.</p>
 <p>The CreateReservationBatch.type indicates the reservation type of the request. If left out the request will be considered of type
 normal. The type can be any of the following values:</p>
 <ul>
     <li>- normal</li>
     <li>- parallel</li>
 </ul>
 <p>The values are subject to change.</p>

 <p>ReservationResponse.success indicates if the reservations were created sucessfully. If any of the reservations have failed then all
 reservations will be failed and ReservationResponse.success will be false. If all reservations are successfully created ReservationResponse.success will be true.

 <p></p>

 <p>ReservationResponse.reservationResults contains details about each reservation.
 A ReservationResult.result has the status of a reservation and can be any of the following values:</p>
 <ul>
     <li>- success</li>
     <li>- patron_is_blocked</li>
     <li>- patron_not_found</li>
     <li>- already_reserved</li>
     <li>- already_loaned</li>
     <li>- material_not_loanable</li>
     <li>- material_not_reservable</li>
     <li>- material_lost</li>
     <li>- material_Discarded</li>
     <li>- loaning_profile_not_found</li>
     <li>- material_not_found</li>
     <li>- material_part_of_collection</li>
     <li>- not_reservable</li>
     <li>- no_reservable_materials</li>
     <li>- interlibrary_material_not_reservable</li>
     <li>- previously_loaned_by_homebound_patron</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as an error.</p>

 <p></p>

 The reservation detail in the response contains a reservation state, which can be any of these values:
 <ul>
     <li>- reserved</li>
     <li>- readyForPickup</li>
     <li>- interLibraryReservation</li>
     <li>- inTransit</li>
     <li>- other</li>
 </ul>
 <p>The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other'.</p>

 <p></p>

 <p>
     When making a reservation of a periodical, the values to put in the PeriodicalReservation structure can be obtained
     from the periodical information retrieved with the Catalog service.
 </p>
 * @summary Create new reservations for the patron.
 */
export const addReservationsV2 = (
  createReservationBatchV2: BodyType<CreateReservationBatchV2>
) => {
  return fetcher<ReservationResponseV2>({
    url: `/external/v1/agencyid/patrons/patronid/reservations/v2`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createReservationBatchV2
  });
};

export type AddReservationsV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof addReservationsV2>>
>;
export type AddReservationsV2MutationBody = BodyType<CreateReservationBatchV2>;
export type AddReservationsV2MutationError = ErrorType<void>;

export const useAddReservationsV2 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addReservationsV2>>,
    TError,
    { data: BodyType<CreateReservationBatchV2> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addReservationsV2>>,
    { data: BodyType<CreateReservationBatchV2> }
  > = (props) => {
    const { data } = props ?? {};

    return addReservationsV2(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof addReservationsV2>>,
    TError,
    { data: BodyType<CreateReservationBatchV2> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of availability for each bibliographical record.
 * @summary Get availability of bibliographical records.
 */
export const getAvailabilityV3 = (
  params?: GetAvailabilityV3Params,
  signal?: AbortSignal
) => {
  return fetcher<AvailabilityV3[]>({
    url: `/external/agencyid/catalog/availability/v3`,
    method: "get",
    signal,
    params
  });
};

export const getGetAvailabilityV3QueryKey = (
  params?: GetAvailabilityV3Params
) => [
  `/external/agencyid/catalog/availability/v3`,
  ...(params ? [params] : [])
];

export type GetAvailabilityV3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAvailabilityV3>>
>;
export type GetAvailabilityV3QueryError = ErrorType<void>;

export const useGetAvailabilityV3 = <
  TData = Awaited<ReturnType<typeof getAvailabilityV3>>,
  TError = ErrorType<void>
>(
  params?: GetAvailabilityV3Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getAvailabilityV3>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAvailabilityV3QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAvailabilityV3>>
  > = ({ signal }) => getAvailabilityV3(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getAvailabilityV3>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 Returns an array of holdings for each bibliographical record.
 The holdings lists the materials on each placement, and whether they are available on-shelf or lent out.
 * @summary Get placement holdings for bibliographical records.
 */
export const getHoldingsV3 = (
  params?: GetHoldingsV3Params,
  signal?: AbortSignal
) => {
  return fetcher<HoldingsForBibliographicalRecordV3[]>({
    url: `/external/agencyid/catalog/holdings/v3`,
    method: "get",
    signal,
    params
  });
};

export const getGetHoldingsV3QueryKey = (params?: GetHoldingsV3Params) => [
  `/external/agencyid/catalog/holdings/v3`,
  ...(params ? [params] : [])
];

export type GetHoldingsV3QueryResult = NonNullable<
  Awaited<ReturnType<typeof getHoldingsV3>>
>;
export type GetHoldingsV3QueryError = ErrorType<void>;

export const useGetHoldingsV3 = <
  TData = Awaited<ReturnType<typeof getHoldingsV3>>,
  TError = ErrorType<void>
>(
  params?: GetHoldingsV3Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getHoldingsV3>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHoldingsV3QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHoldingsV3>>> = ({
    signal
  }) => getHoldingsV3(params, signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getHoldingsV3>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 Returns array of fees.
 <p>If the fee covers loaned materials, information about the materials is returned.
 Each fee in the response includes a 'type', which is used to distinguish between different types of
 fees.</p>
 <p>If the material exists no more, which is the case for fees that are related to closed interlibraryloans,
 then the fee is still returned, but without material information</p>
 The list of available types currently is
 <ul>
 <li>fee</li>
 <li>compensation</li>
 </ul>
 <p>While the type can be used by client systems to look up a suitable display message for the end user, it is
 important that unrecognized types are treated as 'other'.</p>
 * @summary List of fees in FBS for the patron with all available information about the fee.
 */
export const getFeesV2 = (params?: GetFeesV2Params, signal?: AbortSignal) => {
  return fetcher<FeeV2[]>({
    url: `/external/agencyid/patron/patronid/fees/v2`,
    method: "get",
    signal,
    params
  });
};

export const getGetFeesV2QueryKey = (params?: GetFeesV2Params) => [
  `/external/agencyid/patron/patronid/fees/v2`,
  ...(params ? [params] : [])
];

export type GetFeesV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getFeesV2>>
>;
export type GetFeesV2QueryError = ErrorType<void>;

export const useGetFeesV2 = <
  TData = Awaited<ReturnType<typeof getFeesV2>>,
  TError = ErrorType<void>
>(
  params?: GetFeesV2Params,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getFeesV2>>,
      TError,
      TData
    >;
  }
): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFeesV2QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFeesV2>>> = ({
    signal
  }) => getFeesV2(params, signal);

  const query = useQuery<Awaited<ReturnType<typeof getFeesV2>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 When a patron doesn't have a patron account in the library system, but logs in using a trusted authentication
 source (e.g NemId), the patron account can be created using this service. Name and address will be automatically
 fetched from CPR-Registry, and cannot be supplied by the client. If the CPR-Registry is not authorized to
 provide information about the patron, then repsonse message 404 will be sent back
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Create a new patron who is a person.
 */
export const createV4 = (
  createPatronRequestV3: BodyType<CreatePatronRequestV3>
) => {
  return fetcher<AuthenticatedPatronV4>({
    url: `/external/agencyid/patrons/v4`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: createPatronRequestV3
  });
};

export type CreateV4MutationResult = NonNullable<
  Awaited<ReturnType<typeof createV4>>
>;
export type CreateV4MutationBody = BodyType<CreatePatronRequestV3>;
export type CreateV4MutationError = ErrorType<void>;

export const useCreateV4 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createV4>>,
    TError,
    { data: BodyType<CreatePatronRequestV3> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createV4>>,
    { data: BodyType<CreatePatronRequestV3> }
  > = (props) => {
    const { data } = props ?? {};

    return createV4(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createV4>>,
    TError,
    { data: BodyType<CreatePatronRequestV3> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 

 Returns the id of the patron if the request succeeds.
 Name and address will be automatically fetched from the CPR-Registry.
 <p>If the CPR-Registry is not authorized to provide information about the patron, then response message 404 will be sent back.</p>
 <p>If the supplied cpr number of the patron equals that of the guardian, then response message 400 will be sent back.</p>
 <p>If the email of the guardian is invalid, then response message 400 will be sent back.</p>
 <p>If an email or phone number for the patron is supplied and it is invalid, then response message 400 will be sent back.</p>
 <p>In case of a successful creation of the patron, a confirmation email is sent to the guardian.
 In case of failure an email is sent to guardian stating the creation failed.</p>
 * @summary Creates a person patron with a guardian (eg A financial responsible).
 */
export const createWithGuardian = (
  patronWithGuardianRequest: BodyType<PatronWithGuardianRequest>
) => {
  return fetcher<number>({
    url: `/external/agencyid/patrons/withGuardian/v1`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: patronWithGuardianRequest
  });
};

export type CreateWithGuardianMutationResult = NonNullable<
  Awaited<ReturnType<typeof createWithGuardian>>
>;
export type CreateWithGuardianMutationBody =
  BodyType<PatronWithGuardianRequest>;
export type CreateWithGuardianMutationError = ErrorType<void>;

export const useCreateWithGuardian = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createWithGuardian>>,
    TError,
    { data: BodyType<PatronWithGuardianRequest> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createWithGuardian>>,
    { data: BodyType<PatronWithGuardianRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return createWithGuardian(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof createWithGuardian>>,
    TError,
    { data: BodyType<PatronWithGuardianRequest> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 If the person doesn't have a guardian, a new one is created with the information provided.

 Returns the id of the patron if the request succeeds.
 Name and address will be automatically fetched from the CPR-Registry.
 <p>If the CPR-Registry is not authorized to provide information about the patron and guardian, then response message 404 will be sent back.</p>
 <p>If the supplied cpr number of the patron equals that of the guardian, then response message 400 will be sent back.</p>
 <p>If the email of the guardian is invalid, then response message 400 will be sent back.</p>
 <p>In case of a successful update of the guardian, a confirmation email is sent to the guardian.
 In case of failure an email is sent to guardian stating the update failed.</p>
 * @summary Updates a person patron's guardian (eg A financial responsible).
 */
export const updateGuardian = (
  updateGuardianRequest: BodyType<UpdateGuardianRequest>
) => {
  return fetcher<number>({
    url: `/external/agencyid/patrons/withGuardian/v1`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updateGuardianRequest
  });
};

export type UpdateGuardianMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGuardian>>
>;
export type UpdateGuardianMutationBody = BodyType<UpdateGuardianRequest>;
export type UpdateGuardianMutationError = ErrorType<void>;

export const useUpdateGuardian = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGuardian>>,
    TError,
    { data: BodyType<UpdateGuardianRequest> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGuardian>>,
    { data: BodyType<UpdateGuardianRequest> }
  > = (props) => {
    const { data } = props ?? {};

    return updateGuardian(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateGuardian>>,
    TError,
    { data: BodyType<UpdateGuardianRequest> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of the updated loans.
 <p>
 If the materials could not be renewed, the return date will be unchanged.
 </p>

 The response field renewalStatus will contain a list of one or more of these values:
 <ul>
 <li>- renewed</li>
 <li>- deniedReserved</li>
 <li>- deniedMaxRenewalsReached</li>
 <li>- deniedLoanerIsBlocked</li>
 <li>- deniedMaterialIsNotLoanable</li>
 <li>- deniedMaterialIsNotFound</li>
 <li>- deniedLoanerNotFound</li>
 <li>- deniedLoaningProfileNotFound</li>
 <li>- deniedOtherReason</li>
 </ul>
 <p>
 If any other value is encountered then it must be treated as 'deniedOtherReason'.
 </p>
 The response contains the field loanDetails.loanType, which can be any of these values:
 <ul>
 <li>- loan</li>
 <li>- interLibraryLoan</li>
 </ul>
 <p>
 The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other' .
 </p>
 * @summary Renew loans.
 */
export const renewLoansV2 = (renewLoansV2Body: number[]) => {
  return fetcher<RenewedLoanV2[]>({
    url: `/external/agencyid/patrons/patronid/loans/renew/v2`,
    method: "post",
    headers: { "Content-Type": "application/json" },
    data: renewLoansV2Body
  });
};

export type RenewLoansV2MutationResult = NonNullable<
  Awaited<ReturnType<typeof renewLoansV2>>
>;
export type RenewLoansV2MutationBody = BodyType<number[]>;
export type RenewLoansV2MutationError = ErrorType<void>;

export const useRenewLoansV2 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof renewLoansV2>>,
    TError,
    { data: BodyType<number[]> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof renewLoansV2>>,
    { data: BodyType<number[]> }
  > = (props) => {
    const { data } = props ?? {};

    return renewLoansV2(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof renewLoansV2>>,
    TError,
    { data: BodyType<number[]> },
    TContext
  >(mutationFn, mutationOptions);
};

/**
 * 
 Returns an array of loans.
 <p>
 </p>
 If a loan is not renewable then the field renewalStatus will contain a list of one or more of these values:
 <ul>
 <li>- deniedReserved</li>
 <li>- deniedMaxRenewalsReached</li>
 <li>- deniedLoanerIsBlocked</li>
 <li>- deniedMaterialIsNotLoanable</li>
 <li>- deniedMaterialIsNotFound</li>
 <li>- deniedLoanerNotFound</li>
 <li>- deniedLoaningProfileNotFound</li>
 <li>- deniedOtherReason</li>
 </ul>
 <p>
 If any other value is encountered then it must be treated as 'deniedOtherReason'.
 </p>
 The response contains the field loanDetails.loanType, which can be any of these values:
 <ul>
 <li>- loan</li>
 <li>- interLibraryLoan</li>
 </ul>
 <p>
 The values are subject to change. If an unrecognized value is encountered, it should be treated as 'other' .
 </p>
 <p>
 NOTE: Cicero can decide to skip evaluation of the returned loans to minimize response time for loaners with
 many loans. In that case isRenewable will have the value true, as if it were a successful validation.
 </p>
 * @summary Get list of current loans by the patron.
 */
export const getLoansV2 = (signal?: AbortSignal) => {
  return fetcher<LoanV2[]>({
    url: `/external/agencyid/patrons/patronid/loans/v2`,
    method: "get",
    signal
  });
};

export const getGetLoansV2QueryKey = () => [
  `/external/agencyid/patrons/patronid/loans/v2`
];

export type GetLoansV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getLoansV2>>
>;
export type GetLoansV2QueryError = ErrorType<void>;

export const useGetLoansV2 = <
  TData = Awaited<ReturnType<typeof getLoansV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getLoansV2>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLoansV2QueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLoansV2>>> = ({
    signal
  }) => getLoansV2(signal);

  const query = useQuery<Awaited<ReturnType<typeof getLoansV2>>, TError, TData>(
    queryKey,
    queryFn,
    queryOptions
  );

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Returns the patron details
 */
export const getPatronInformationByPatronIdV2 = (signal?: AbortSignal) => {
  return fetcher<AuthenticatedPatronV6>({
    url: `/external/agencyid/patrons/patronid/v2`,
    method: "get",
    signal
  });
};

export const getGetPatronInformationByPatronIdV2QueryKey = () => [
  `/external/agencyid/patrons/patronid/v2`
];

export type GetPatronInformationByPatronIdV2QueryResult = NonNullable<
  Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>
>;
export type GetPatronInformationByPatronIdV2QueryError = ErrorType<void>;

export const useGetPatronInformationByPatronIdV2 = <
  TData = Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
  TError = ErrorType<void>
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
    TError,
    TData
  >;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetPatronInformationByPatronIdV2QueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>
  > = ({ signal }) => getPatronInformationByPatronIdV2(signal);

  const query = useQuery<
    Awaited<ReturnType<typeof getPatronInformationByPatronIdV2>>,
    TError,
    TData
  >(queryKey, queryFn, queryOptions);

  return {
    queryKey,
    ...query
  };
};

/**
 * 
 The name and address cannot be supplied by the client. If the CPR-Registry is not authorized to provide
 information about the patron, then the name and address will not be updated.
 <p>It is possible to either update just the pincode, update just some patron settings, or update both.</p>
 <p></p>
 If a patron is blocked the reason is available as a code:
 <ul>
     <li>- 'O': library card stolen</li>
     <li>- 'U': exclusion</li>
     <li>- 'F': extended exclusion</li>
     <li>- 'S': blocked by self service automaton</li>
     <li>- 'W': self created at website</li>
 </ul>
 <p>The codes are informational, and can be used for looking up end user messages by the client system. However,
 the list is subject to change at any time, so any unexpected values should be interpreted as 'other reason'.</p>
 * @summary Update information about the patron.
 */
export const updateV5 = (
  updatePatronRequestV4: BodyType<UpdatePatronRequestV4>
) => {
  return fetcher<AuthenticatedPatronV6>({
    url: `/external/agencyid/patrons/patronid/v5`,
    method: "put",
    headers: { "Content-Type": "application/json" },
    data: updatePatronRequestV4
  });
};

export type UpdateV5MutationResult = NonNullable<
  Awaited<ReturnType<typeof updateV5>>
>;
export type UpdateV5MutationBody = BodyType<UpdatePatronRequestV4>;
export type UpdateV5MutationError = ErrorType<void>;

export const useUpdateV5 = <
  TError = ErrorType<void>,
  TContext = unknown
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateV5>>,
    TError,
    { data: BodyType<UpdatePatronRequestV4> },
    TContext
  >;
}) => {
  const { mutation: mutationOptions } = options ?? {};

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateV5>>,
    { data: BodyType<UpdatePatronRequestV4> }
  > = (props) => {
    const { data } = props ?? {};

    return updateV5(data);
  };

  return useMutation<
    Awaited<ReturnType<typeof updateV5>>,
    TError,
    { data: BodyType<UpdatePatronRequestV4> },
    TContext
  >(mutationFn, mutationOptions);
};
